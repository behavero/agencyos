import { createAdminClient } from '@/lib/supabase/server'

export interface PayrollEmployee {
  id: string
  username: string | null
  role: string | null
  base_salary: number
  commission_rate: number
  payment_method: string | null
  avatar_url?: string | null
}

export interface PayrollLineItem {
  employee: PayrollEmployee
  baseSalary: number
  revenueGenerated: number
  commissionRate: number
  commissionAmount: number
  bonuses: number
  deductions: number
  total: number
  modelsCovered: string[]
}

export interface PayrollSummary {
  periodStart: Date
  periodEnd: Date
  lineItems: PayrollLineItem[]
  totalBase: number
  totalCommission: number
  totalBonuses: number
  totalDeductions: number
  grandTotal: number
  agencyRevenue: number
}

export class PayrollCalculator {
  private supabase: ReturnType<typeof createAdminClient> | null = null

  private async getClient() {
    if (!this.supabase) {
      this.supabase = await createAdminClient()
    }
    return this.supabase
  }

  /**
   * Generate payroll for a given period
   */
  async generatePayroll(
    agencyId: string,
    startDate: Date,
    endDate: Date
  ): Promise<PayrollSummary> {
    const supabase = await this.getClient()

    // Step 1: Fetch all active employees
    const { data: employees, error: employeesError } = await supabase
      .from('profiles')
      .select('id, username, role, base_salary, commission_rate, payment_method, avatar_url')
      .eq('agency_id', agencyId)
      .not('role', 'is', null)

    if (employeesError) {
      console.error('Error fetching employees:', employeesError)
      throw new Error('Failed to fetch employees')
    }

    // Step 2: Fetch all models for the agency
    const { data: models, error: modelsError } = await supabase
      .from('models')
      .select('id, name, total_revenue')
      .eq('agency_id', agencyId)

    if (modelsError) {
      console.error('Error fetching models:', modelsError)
      throw new Error('Failed to fetch models')
    }

    // Step 3: Fetch model assignments
    const { data: assignments, error: assignmentsError } = await supabase
      .from('model_assignments')
      .select('model_id, profile_id, commission_override')
      .eq('is_active', true)

    // Step 4: Fetch transactions for the period to calculate revenue
    const { data: transactions, error: transactionsError } = await supabase
      .from('transactions')
      .select('model_id, amount, created_at')
      .eq('agency_id', agencyId)
      .gte('created_at', startDate.toISOString())
      .lte('created_at', endDate.toISOString())

    // Calculate revenue per model in the period
    const revenueByModel = new Map<string, number>()
    if (transactions) {
      for (const tx of transactions) {
        if (tx.model_id) {
          const current = revenueByModel.get(tx.model_id) || 0
          revenueByModel.set(tx.model_id, current + (tx.amount || 0))
        }
      }
    }

    // Build assignment map (profile -> models)
    const employeeModels = new Map<string, { modelId: string; commission?: number }[]>()
    if (assignments) {
      for (const assignment of assignments) {
        const current = employeeModels.get(assignment.profile_id) || []
        current.push({
          modelId: assignment.model_id,
          commission: assignment.commission_override,
        })
        employeeModels.set(assignment.profile_id, current)
      }
    }

    // Step 5: Calculate payroll for each employee
    const lineItems: PayrollLineItem[] = []
    let totalBase = 0
    let totalCommission = 0
    let totalBonuses = 0
    let totalDeductions = 0
    let grandTotal = 0
    let agencyRevenue = 0

    // Calculate total agency revenue
    for (const [, revenue] of revenueByModel) {
      agencyRevenue += revenue
    }

    for (const employee of employees || []) {
      const baseSalary = employee.base_salary || 0
      const defaultCommissionRate = employee.commission_rate || 0

      // Get assigned models for this employee
      const assignedModels = employeeModels.get(employee.id) || []
      
      // Calculate revenue generated by this employee's models
      let revenueGenerated = 0
      const modelsCovered: string[] = []
      
      for (const assignment of assignedModels) {
        const modelRevenue = revenueByModel.get(assignment.modelId) || 0
        revenueGenerated += modelRevenue
        
        const model = models?.find(m => m.id === assignment.modelId)
        if (model) {
          modelsCovered.push(model.name)
        }
      }

      // If no specific assignments, managers/grandmasters get commission on all revenue
      if (assignedModels.length === 0 && (employee.role === 'grandmaster' || employee.role === 'paladin')) {
        revenueGenerated = agencyRevenue
        modelsCovered.push('All Models')
      }

      // Calculate commission
      const commissionRate = defaultCommissionRate
      const commissionAmount = revenueGenerated * commissionRate

      // TODO: Add bonus/deduction logic from separate tables
      const bonuses = 0
      const deductions = 0

      const total = baseSalary + commissionAmount + bonuses - deductions

      const lineItem: PayrollLineItem = {
        employee: employee as PayrollEmployee,
        baseSalary,
        revenueGenerated,
        commissionRate,
        commissionAmount,
        bonuses,
        deductions,
        total,
        modelsCovered,
      }

      lineItems.push(lineItem)

      totalBase += baseSalary
      totalCommission += commissionAmount
      totalBonuses += bonuses
      totalDeductions += deductions
      grandTotal += total
    }

    return {
      periodStart: startDate,
      periodEnd: endDate,
      lineItems,
      totalBase,
      totalCommission,
      totalBonuses,
      totalDeductions,
      grandTotal,
      agencyRevenue,
    }
  }

  /**
   * Save draft payouts to database
   */
  async saveDraftPayouts(
    agencyId: string,
    payroll: PayrollSummary,
    createdBy: string
  ): Promise<string[]> {
    const supabase = await this.getClient()
    const payoutIds: string[] = []

    for (const item of payroll.lineItems) {
      const { data, error } = await supabase
        .from('payouts')
        .insert({
          agency_id: agencyId,
          recipient_id: item.employee.id,
          period_start: payroll.periodStart.toISOString().split('T')[0],
          period_end: payroll.periodEnd.toISOString().split('T')[0],
          amount_base: item.baseSalary,
          amount_commission: item.commissionAmount,
          amount_bonus: item.bonuses,
          amount_deductions: item.deductions,
          revenue_generated: item.revenueGenerated,
          commission_rate: item.commissionRate,
          models_covered: item.modelsCovered,
          payment_method: item.employee.payment_method,
          status: 'draft',
          created_by: createdBy,
        })
        .select('id')
        .single()

      if (error) {
        console.error('Error creating payout:', error)
        continue
      }

      if (data) {
        payoutIds.push(data.id)
      }
    }

    return payoutIds
  }

  /**
   * Mark a payout as paid
   */
  async markAsPaid(
    payoutId: string,
    paidBy: string,
    paymentReference?: string
  ): Promise<boolean> {
    const supabase = await this.getClient()

    const { error } = await supabase
      .from('payouts')
      .update({
        status: 'paid',
        paid_at: new Date().toISOString(),
        paid_by: paidBy,
        payment_reference: paymentReference,
        updated_at: new Date().toISOString(),
      })
      .eq('id', payoutId)

    if (error) {
      console.error('Error marking payout as paid:', error)
      return false
    }

    return true
  }
}

export const payrollCalculator = new PayrollCalculator()
